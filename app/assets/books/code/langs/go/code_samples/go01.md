# Basic GO program

TOOOO  ADDDD:   https://www.bogotobogo.com/GoLang/GoLang_HelloWorld.php


hello.go
```go
package main
import "fmt"
func main() {
   fmt.Println("hello")
}
```
>go run hello.go

::::

# Random

ramdom.go
```go
package main

import "math/rand"

func main() {
  for i := 0; i < 10; i++ {
    println(rand.Intn(25))
  }
}
```
>go run random.go

# Aliasing

```go
package main

import (
 f "fmt"          // Printf refer now as f.Printf rather than fmt.Printf
  "math/rand"
)

func main() {
  for i := 0; i < 10; i++ {
    f.Printf("%d) %d\n", i, rand.Intn(25))
  }
}
```

::::

# Format string

```go
package main
import "fmt"
func main() {
  s := fmt.Sprintf("Size: %d MB.", 85) 
  // without printing is to use the fmt.Sprintf()
  // which returns a string without printing it
  fmt.Println(s)
}
```

::::

# swap values

```go
package main
import "fmt"
func main() {
   fmt.Println(swap())
}
func swap() []int {
   a, b := 15, 10
   b, a = a, b
   return []int{a, b}
}
```

Check if a slice is empty:
```go
package main
import "fmt"
func main() {
  r := [3]int{1, 2, 3}
  if len(r) == 0 {
    fmt.Println("Empty!")
  } else {
    fmt.Println("Not Empty!")
  }
}
```

::::

# Stack implemntation (LIFO)

```go
package main
import "fmt"
func main() {
// Create
var stack []string
// Push
stack = append(stack, "world!")
stack = append(stack, "Hello ")
for len(stack) > 0 {
        // Print top
        n := len(stack) - 1
        fmt.Print(stack[n])
        // Pop
        stack = stack[:n]
}
// Output: Hello world!
}
```

::::

# Permutations

```go
package main
import "fmt"
// Perm calls f with each permutation of a.
func Perm(a []rune, f func([]rune)) {
        perm(a, f, 0)
}
// Permute the values at index i to len(a)-1.
func perm(a []rune, f func([]rune), i int) {
        if i > len(a) {
                f(a)
                return
        }
        perm(a, f, i+1)
        for j := i + 1; j < len(a); j++ {
                a[i], a[j] = a[j], a[i]
                perm(a, f, i+1)
                a[i], a[j] = a[j], a[i]
        }
}
func main() {
Perm([]rune("abc"), func(a []rune) {
        fmt.Println(string(a))
})
}
```

::::

# Min-Max

```go
package main
import "fmt"
// Min returns the smaller of x or y.
func Min(x, y int) int {
        if x > y {
            return y
        }
        return x
}
// Max returns the larger of x or y.
func Max(x, y int) int {
        if x < y {
            return y
        }
        return x
}
func main() { 
    fmt.Println(Min(5,10))
    fmt.Println(Max(5,10))
}
```
::::

# Reverse a slice of integers 

without using a temporary slice...

```go
package main
import "fmt"
func reverse(sw []int) {
        for a, b := 0, len(sw)-1; a < b; a, b = a+1, b-1 {
                sw[a], sw[b] = sw[b], sw[a]
        } 
}
func main() { 
    x := []int{3, 2, 1} 
    reverse(x)
    fmt.Println(x)
}
```
::::

# Concurrent merge sort solution using goroutines and channels

sequential merge sort 

```go
package main
import "fmt"

func Merge(left, right [] int) [] int{
  merged := make([] int, 0, len(left) + len(right))
  for len(left) > 0 || len(right) > 0{
    if len(left) == 0 {
      return append(merged,right...)
    }else if len(right) == 0 {
      return append(merged,left...)
    }else if left[0] < right[0] {
      merged = append(merged, left[0])
      left = left[1:]
    }else{
      merged = append(merged, right [0])
      right = right[1:]
    }
  }
  return merged
}

func MergeSort(data [] int) [] int {
  if len(data) <= 1 {
    return data
  }
  mid := len(data)/2
  left := MergeSort(data[:mid])
  right := MergeSort(data[mid:])
  return Merge(left,right)
}

func main(){
  data := [] int{9,4,3,6,1,2,10,5,7,8}
  fmt.Printf("%v\n%v\n", data, MergeSort(data))
}
```


```go
package main
import "fmt"

func Merge(left, right [] int) [] int{
  merged := make([] int, 0, len(left) + len(right))
  for len(left) > 0 || len(right) > 0{
    if len(left) == 0 {
      return append(merged,right...)
    }else if len(right) == 0 {
      return append(merged,left...)
    }else if left[0] < right[0] {
      merged = append(merged, left[0])
      left = left[1:]
    }else{
      merged = append(merged, right [0])
      right = right[1:]
    }
  }
  return merged
}

func MergeSort(data [] int) [] int {
  if len(data) <= 1 {
    return data
  }
  done := make(chan bool)
  mid := len(data)/2
  var left [] int
  go func(){
    left = MergeSort(data[:mid])
    done <- true
  }()
  right := MergeSort(data[mid:])
  <-done
  return Merge(left,right)
}

func main(){
  data := [] int{9,4,3,6,1,2,10,5,7,8}
  fmt.Printf("%v\n%v\n", data, MergeSort(data))
}
```


```
```

